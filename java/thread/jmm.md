# Java内存模型JMM
JMM规定，所有的变量都放在主内存中，这些变量称为共享变量（包括静态变量、实例变量等）。每个线程对共享变量进行读写之前，都需要将共享变量从主内存中加载到自己的工作内存，在工作内存中对变量进行读写，最后会和主内存有个同步过程。

1. 对一个volatile变量的写操作和对一个锁的释放具有相同的执行效果，会将当前线程的本地内存中对共享变量的写操作同步到主内存中
2. 对一个volatile变量的读操作和对一个锁的获取具有相同的执行效果，会将当前线程的本地内存中的共享变量置为无效，从主内存中获取共享变量的值

### volatile
volatile变量的单个读/写具有原子性，如validatile++操作不具有原子性
通过内存屏障防止编译器和处理器的重排序

多个线程对一个volatile进行写操作不具备线程安全，因为volatile不保证原子性。它只能保证读取一个volatile变量时是最新值，因此适合用来当作状态，比如唤醒一个while循环

==注：volatile只能保证读取时是最新值，不是说只要volatile修饰就是线程安全==


